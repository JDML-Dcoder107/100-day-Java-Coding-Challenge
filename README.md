# 100-day-Java-Coding-Challenge
this compiles the day by day challenges in java leveling from beginner to advance level. 

# 100-Day Java Coding Challenge Plan

## Week 1: Fundamentals (Days 1-7)

**Day 1**
- Print "Hello, World!"

**Day 2**
- Add two numbers
- Check if a number is even or odd

**Day 3**
- Find the largest of three numbers
- Convert Celsius to Fahrenheit

**Day 4**
- Calculate factorial using iteration
- Calculate the power of a number (x^n)

**Day 5**
- Reverse a string
- Count the number of vowels in a string

**Day 6**
- Check if a string is a palindrome
- Remove all whitespace from a string

**Day 7**
- Print Fibonacci series up to n terms
- Count the number of digits in a number

---

## Week 2: Arrays & Basic Algorithms (Days 8-14)

**Day 8**
- Find the sum of elements in an array
- Find the smallest element in an array

**Day 9**
- Check if a year is a leap year
- Print multiplication table of a given number

**Day 10**
- Check if a number is prime
- Print all prime numbers between 1 and n

**Day 11**
- Find GCD of two numbers
- Find LCM of two numbers

**Day 12**
- Swap two numbers without using a third variable
- Calculate the sum of digits of a number

**Day 13**
- Check if a number is Armstrong number
- Generate first n prime numbers

**Day 14**
- Remove duplicates from an array
- Find the second largest element in an array

---

## Week 3: Sorting & Searching Basics (Days 15-21)

**Day 15**
- Implement bubble sort algorithm

**Day 16**
- Implement selection sort algorithm

**Day 17**
- Implement insertion sort algorithm

**Day 18**
- Implement linear search
- Implement binary search on a sorted array

**Day 19**
- Find missing number in array of 1 to n
- Rotate an array by k positions

**Day 20**
- Merge two sorted arrays
- Find the intersection of two arrays

**Day 21**
- Calculate the median of an array
- Find the kth largest element in an array

---

## Week 4: String Manipulation (Days 22-28)

**Day 22**
- Check if two strings are anagrams
- Count occurrences of each character in a string

**Day 23**
- Find first non-repeating character in a string
- Reverse words in a sentence

**Day 24**
- Check if a string contains only digits
- Convert a string to integer (atoi)

**Day 25**
- Implement Caesar cipher encryption
- Implement string compression (e.g., "aaabbc" -> "a3b2c1")

**Day 26**
- Find the longest substring without repeating characters

**Day 27**
- Find longest palindromic substring
- Check if parentheses are balanced in an expression

**Day 28**
- Find all permutations of a string

---

## Week 5: Data Structures - Stacks & Queues (Days 29-35)

**Day 29**
- Implement a stack using arrays

**Day 30**
- Implement a queue using arrays

**Day 31**
- Implement stack using two queues (or vice versa)

**Day 32**
- Solve expression evaluation with precedence

**Day 33**
- Check if parentheses are balanced (using stack)

**Day 34**
- Implement a simple calculator (add, subtract, multiply, divide)

**Day 35**
- Design a min-stack (stack that supports getMin in O(1))

---

## Week 6: Arrays & Problem Solving (Days 36-42)

**Day 36**
- Find pairs in array with given sum

**Day 37**
- Find all unique triplets that sum to zero (3Sum problem)

**Day 38**
- Count the frequency of each element in an array

**Day 39**
- Find the majority element in an array

**Day 40**
- Print all subsets of a set

**Day 41**
- Implement two-pointer technique problems

**Day 42**
- Solve sliding window problems

---

## Week 7: Linked Lists Basics (Days 43-49)

**Day 43**
- Implement a singly linked list with insert and delete

**Day 44**
- Reverse a linked list (iterative)

**Day 45**
- Reverse a linked list (recursive)

**Day 46**
- Find the middle element of a linked list

**Day 47**
- Check if a linked list has a cycle (Floyd's algorithm)

**Day 48**
- Find the start of cycle in linked list

**Day 49**
- Merge two sorted linked lists

---

## Week 8: Advanced Sorting (Days 50-56)

**Day 50**
- Implement merge sort algorithm

**Day 51**
- Implement quick sort algorithm

**Day 52**
- Implement heap sort algorithm

**Day 53**
- Implement counting sort

**Day 54**
- Understand and implement radix sort

**Day 55**
- Compare time complexities of all sorting algorithms

**Day 56**
- Practice custom sorting with comparators

---

## Week 9: Recursion & Backtracking (Days 57-63)

**Day 57**
- Solve Tower of Hanoi problem

**Day 58**
- Generate all subsets using backtracking

**Day 59**
- Generate all permutations using backtracking

**Day 60**
- Solve N-Queens problem

**Day 61**
- Solve Sudoku solver using backtracking

**Day 62**
- Word search in a 2D grid

**Day 63**
- Generate all valid parentheses combinations

---

## Week 10: Binary Trees Basics (Days 64-70)

**Day 64**
- Implement a binary tree with insert and search

**Day 65**
- Traverse binary tree: Inorder, Preorder, Postorder

**Day 66**
- Implement level order traversal (BFS)

**Day 67**
- Find height/depth of a binary tree

**Day 68**
- Check if a binary tree is balanced

**Day 69**
- Convert binary tree to its mirror image

**Day 70**
- Find diameter of a binary tree

---

## Week 11: Binary Search Trees (Days 71-77)

**Day 71**
- Implement BST with insert, delete, search

**Day 72**
- Find minimum and maximum in BST

**Day 73**
- Check if a tree is a valid BST

**Day 74**
- Find kth smallest element in BST

**Day 75**
- Find lowest common ancestor in BST

**Day 76**
- Convert sorted array to balanced BST

**Day 77**
- Serialize and deserialize a binary tree

---

## Week 12: Advanced Tree Problems (Days 78-84)

**Day 78**
- Find maximum path sum in a binary tree

**Day 79**
- Count number of nodes in a complete binary tree

**Day 80**
- Implement Trie (prefix tree) data structure

**Day 81**
- Implement autocomplete using Trie

**Day 82**
- Solve word break problem using Trie

**Day 83**
- Implement segment tree for range queries

**Day 84**
- Practice tree problems with DFS and BFS

---

## Week 13: Graphs - Basics (Days 85-91)

**Day 85**
- Represent graphs using adjacency list and matrix

**Day 86**
- Implement breadth-first search (BFS) on a graph

**Day 87**
- Implement depth-first search (DFS) on a graph

**Day 88**
- Detect cycle in an undirected graph

**Day 89**
- Detect cycle in a directed graph

**Day 90**
- Find all paths between two nodes in a graph

**Day 91**
- Topological sorting

---

## Week 14: Advanced Graph Algorithms (Days 92-98)

**Day 92**
- Implement Dijkstra's shortest path algorithm

**Day 93**
- Implement Bellman-Ford algorithm

**Day 94**
- Find minimum spanning tree (Kruskal's algorithm)

**Day 95**
- Find minimum spanning tree (Prim's algorithm)

**Day 96**
- Solve number of islands problem

**Day 97**
- Find strongly connected components

**Day 98**
- Implement Floyd-Warshall algorithm

---

## Week 15: Dynamic Programming & Design (Days 99-100)

**Day 99**
- Solve coin change problem (DP)
- Solve knapsack problem (0/1 knapsack)
- Find longest increasing subsequence
- Find longest common subsequence

**Day 100** - Final Challenge Day
- Implement LRU Cache
- Design parking lot system (OOP)
- Implement rate limiter (token bucket)
- Design URL shortener
- Implement thread-safe singleton pattern
- Implement producer-consumer problem

---

## Tips for Success

1. **Consistency is Key**: Try to code every day, even if just for 30 minutes
2. **Understand Before Moving On**: Don't just copy solutions; understand the logic
3. **Test Your Code**: Always test with edge cases
4. **Time Yourself**: Try to solve problems within time limits
5. **Review Regularly**: Revisit previous challenges weekly
6. **Join Communities**: Share progress on GitHub or coding forums
7. **Track Progress**: Keep a journal of what you learned each day
8. **Don't Skip Days**: If you miss a day, catch up the next day
9. **Practice Multiple Solutions**: Try to find 2-3 approaches for each problem
10. **Focus on Complexity**: Always analyze time and space complexity

## Difficulty Legend
- Days 1-35: Beginner to Intermediate
- Days 36-70: Intermediate
- Days 71-100: Intermediate to Advanced

Good luck on your 100-day journey! ðŸš€
